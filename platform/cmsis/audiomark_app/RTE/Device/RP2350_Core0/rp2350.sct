#! armclang -E --target=arm-arm-none-eabi -mcpu=cortex-m33 -xc
/* command above MUST be in first line (no comment above!) */

/* Note: Add '-mcmse' to first line if your software model is "Secure Mode". */
/*       #! armclang -E --target=arm-arm-none-eabi -mcpu=cortex-m33 -xc -mcmse */

/*---------------------------------------------------------------------------
 * Name:    rp2350.sct
 * Purpose: ARM Linker Script for for Raspberry Pi RP2350
 *---------------------------------------------------------------------------*/
/*
 * Copyright (c) 2024 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
; <<< Use Configuration Wizard in Context Menu >>>
 */

/*
; <h> Boot Metadata Configuration
;   <i> specify the base address and the complete size of the used Boot Metadata
;   <o0> Boot Metadata Base Address <0x0-0xFFFFFFFF:8>
;   <o1> Boot Metadata Size (in Bytes) <0x0-0xFFFFFFFF:8>
; </h>
 */
#define BOOT_METADATA_START  0x10000000
#define BOOT_METADATA_SIZE   0x00000400

/*
; <h> Flash Configuration
;   <i> specify the base address and the size of the used Flash
;   <o0> Flash Base Address <0x0-0xFFFFFFFF:8>
;   <o1> Flash Size (in Bytes) <0x0-0xFFFFFFFF:8>
; </h>
 */
#define __ROM_BASE           0x10000400
#define __ROM_SIZE           0x001FFC00

/*
; <h> RAM Configuration
;   <i> specify the base address and the complete size of the used RAM
;   <o0> RAM Base Address <0x0-0xFFFFFFFF:8>
;   <o1> RAM Size (in Bytes) <0x0-0xFFFFFFFF:8>
; </h>
 */
#define __RAM_BASE           0x20000000
#define __RAM_SIZE           0x00082000

/*
; <h> Stack / Heap Configuration
;   <i> specify the size used for the Stack, Heap sections
;   <o0> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
;   <o1> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
; </h>
 */
#define __STACK_SIZE         0x00002000
#define __HEAP_SIZE          0x0003C000


/*
; <h> CMSE Veneer Configuration
;   <o0>  CMSE Veneer Size (in Bytes) <0x0-0xFFFFFFFF:32>
; </h>
 */
#define __CMSEVENEER_SIZE    0x00002000

/*
; <<< end of configuration section >>>
 */


#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
#define __STACKSEAL_SIZE   ( 8 )
#else
#define __STACKSEAL_SIZE   ( 0 )
#endif

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
#define __CV_BASE          ( __ROM_BASE + __ROM_SIZE - __CMSEVENEER_SIZE )
#define __CV_SIZE          ( __CMSEVENEER_SIZE )
#else
#define __CV_SIZE          ( 0 )
#endif

#define __LR_BASE          ( __ROM_BASE )
#define __LR_SIZE          ( __ROM_SIZE - __CV_SIZE )



LR_APP __LR_BASE __LR_SIZE  {                                                   /* load region for application */
    ER_APP __LR_BASE __LR_SIZE  {                                               /* execution region for application */
        *.o (RESET, +First)
        *(InRoot$$Sections)
        .ANY (+RO)
        .ANY (+XO)
    }

    ARM_LIB_STACK __RAM_BASE EMPTY FILL 0xDEADBEEF __STACK_SIZE {               /* empty region for stack */
    }

    #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
    STACKSEAL +0 EMPTY __STACKSEAL_SIZE {                                       /* empty region for stack seal immediately after stack */
    }
    #endif

    RW_RAM +0  {                                      /* RW, ZI data */
        .ANY (+RW +ZI)
    }

    RW_NOINIT +0 UNINIT  {                  /* no init data */
        .ANY (.bss.noinit)
    }

    ARM_LIB_HEAP  +0 EMPTY ALIGN 8 __HEAP_SIZE  {                               /* empty region for heap */
    }



    /* This empty, zero long execution region is here to mark the limit address
     * of the last execution region that is allocated in SRAM.
     */
    SRAM_WATERMARK +0 EMPTY 0x0 {
    }
    /* Make sure that the sections allocated in the SRAM does not exceed the
     * size of the SRAM available.
     */
    ScatterAssert(ImageLimit(SRAM_WATERMARK) <= __RAM_BASE + __RAM_SIZE)

}

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
LR_CMSE_VENEER __CV_BASE ALIGN 32 __CV_SIZE  {                                  /* load/execution region for CMSE Veneers */
  ER_CMSE_VENEER __CV_BASE __CV_SIZE  {
   *(Veneer$$CMSE)
  }
}
#endif


LR_BOOT BOOT_METADATA_START BOOT_METADATA_SIZE  {
  ER_BOOT BOOT_METADATA_START BOOT_METADATA_SIZE {
    .ANY (.bootmetadata)
  }
}

